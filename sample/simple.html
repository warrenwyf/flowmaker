<!DOCTYPE html>
<html>

<head>
	<meta http-equiv="Content-Type" content="text/html" charset="utf-8" />
	<title>flowmaker - simple sample</title>

	<style type="text/css">
	html, body {
		overflow: hidden;
		width: 100%;
		height: 100%;
		margin: 0;
		padding: 0;
	}

	#processors {
		float: left;
		width: 20%;
		height: 100%;
		touch-action: none;
		background: #f0f0f0;
	}

	#flow {
		float: right;
		width: 80%;
		height: 100%;
		touch-action: none;
	}

	#buttons {
		position: absolute;
		top: 1em;
		right: 1em;
	}

	#processors ul {
		padding-inline-start: 1em;
	}

	.processor {
		list-style: none;
		margin-bottom: 8px;
		cursor: pointer;
		user-select: none;
	}

	.processor>#icon,
	.processor>#name {
		display: inline-block;
		vertical-align: middle;
	}

	.processor>#icon {
		width: 24px;
		height: 24px;
		margin-right: 8px;
		padding: 4px;
		border-radius: 4px;
		cursor: default;
	}

	.processor>#icon>img {
		width: 24px;
		height: 24px;
	}
	</style>
</head>

<body>

	<div id="processors">
		<ul>
			<li class="processor" draggable="true" ondragstart="onProcessorDragStart(event)" data-type="unknown">
				<div id="icon" style="background: #ccc"><img src="./img/icon-unknown.png" ondragstart="onImgDragStart(event)"></div>
					<text id="name">Unknow</text>
			</li>
			<li class="processor" draggable="true" ondragstart="onProcessorDragStart(event)" data-type="cache">
				<div id="icon" style="background: #faa33e"><img src="./img/icon-cache.png" ondragstart="onImgDragStart(event)"></div>
					<text id="name">Cache</text>
			</li>
		</ul>
	</div>

	<div id="flow" ondragover="onProcessorDragOver(event)" ondrop="onProcessorDrop(event)"></div>

	<div id="buttons">
		<button onclick="onRunClick()">▶︎ Run</button>
		<button onclick="onStopClick()">◼︎ Stop</button>
		<button onclick="onLayoutClick()">Auto Layout</button>
	</div>

	<script type="text/javascript" src="../dist/flowmaker.js"></script>
	<script type="text/javascript">
	console.log('flowmaker version:', flowmaker.version);
	var flow = new flowmaker.Flow('flow');

	function onImgDragStart(e) {
		e.preventDefault();
	}

	function onProcessorDragStart(e) {
		var type = e.target.getAttribute('data-type');
		e.dataTransfer.setData('type', type);
	}

	function onProcessorDragOver(e) {
		e.preventDefault();
	}

	function onProcessorDrop(e) {
		e.preventDefault();

		var type = e.dataTransfer.getData('type');
		var x = e.offsetX;
		var y = e.offsetY;

		switch (type) {
			case 'unknown':
				flow.addNode(newUnknownNode(), x, y);
				break;
			case 'cache':
				flow.addNode(newCacheNode(), x, y);
				break;
		}
	}

	function onRunClick() {
		mockServer.start();
	}

	function onStopClick() {
		mockServer.stop();
	}

	function onLayoutClick() {
		flow.autoLayout();
	}

	function newUnknownNode() {
		return new flowmaker.Node({
			extInfo: { type: 'unknown' },
			icon: 'img/icon-unknown.png',
			rightPorts: [{
				type: 'output',
			}],
		});
	}

	function newCacheNode() {
		return new flowmaker.Node({
			extInfo: { type: 'cache' },
			name: 'Cache',
			desc: '',
			icon: 'img/icon-cache.png',
			bgColor: '#faa33e',
			leftPorts: [{
				type: 'input',
			}, {
				type: 'input',
			}],
			rightPorts: [{
				type: 'output',
			}],
		});
	}

	var nodes1 = [];
	var nodes1Count = 3;
	for (var i = 0; i < nodes1Count; i++) {
		var node1 = newUnknownNode();
		flow.addNode(node1, 200, 200 + 100 * i);
		nodes1.push(node1);
	}

	var nodes2 = [];
	var nodes2Count = 5;
	for (var i = 0; i < nodes2Count; i++) {
		var node2 = newCacheNode();
		flow.addNode(node2, 400, 200 + 100 * i);
		nodes2.push(node2);
	}

	var nodes3 = [];
	var nodes3Count = 4;
	for (var i = 0; i < nodes3Count; i++) {
		var node3 = newCacheNode();
		flow.addNode(node3, 600, 200 + 100 * i);
		nodes3.push(node3);
	}

	var nodes4 = [];
	var nodes4Count = 6;
	for (var i = 0; i < nodes4Count; i++) {
		var node4 = newCacheNode();
		flow.addNode(node4, 800, 200 + 100 * i);
		nodes4.push(node4);
	}

	for (var i = 0; i < nodes2Count; i++) {
		flow.connect(nodes1[parseInt(Math.random() * nodes1Count)].getId(), 'r-0', nodes2[i].getId(), 'l-' + parseInt(Math.random() * 2));
	}

	for (var i = 0; i < nodes3Count; i++) {
		flow.connect(nodes2[parseInt(Math.random() * nodes2Count)].getId(), 'r-0', nodes3[i].getId(), 'l-' + parseInt(Math.random() * 2));
	}

	for (var i = 0; i < nodes4Count; i++) {
		flow.connect(nodes3[parseInt(Math.random() * nodes3Count)].getId(), 'r-0', nodes4[i].getId(), 'l-' + parseInt(Math.random() * 2));
	}

	var mockServer = {
		resetNode: function(nodeId) {
			var node = flow.getNode(nodeId);
			if (!node) {
				console.log('Node does not exists');
				return;
			}

			clearInterval(node._tid);

			flow.sendCommand(JSON.stringify({
				name: 'update_node_status',
				data: {
					nodeId: nodeId,
					status: 'idle',
				}
			}));

			// reset downstream nodes
			var nodes = node.getDownstreamNodes();
			for (var i in nodes) {
				mockServer.resetNode(nodes[i].getId());
			}
		},

		runNode: function(nodeId) {
			var node = flow.getNode(nodeId);
			if (!node) {
				console.log('Node does not exists');
				return;
			}

			mockServer.resetNode(nodeId);

			flow.sendCommand(JSON.stringify({
				name: 'update_node_status',
				data: {
					nodeId: nodeId,
					status: 'running',
				}
			}));

			var progress = 0;
			node._tid = setInterval(function() {
				progress += Math.random() * 10;
				if (progress > 100) {
					clearInterval(node._tid);

					flow.sendCommand(JSON.stringify({
						name: 'update_node_status',
						data: {
							nodeId: nodeId,
							status: 'success',
						}
					}));

					// run downstream nodes
					var nodes = node.getDownstreamNodes();
					for (var i in nodes) {
						mockServer.runNode(nodes[i].getId());
					}
				}

				flow.sendCommand(JSON.stringify({
					name: 'update_node_progress',
					data: {
						nodeId: nodeId,
						progress: progress,
					}
				}));
			}, 500);
		},

		start: function() {
			for (var i in nodes1) {
				mockServer.runNode(nodes1[i].getId());
			}
		},


		stop: function() {
			for (var i in nodes1) {
				clearInterval(nodes1[i]._tid);
			}

			for (var i in nodes2) {
				clearInterval(nodes2[i]._tid);
			}
		},

	};
	</script>

</body>

</html>